"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[118],{7322:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"introduction/overview","title":"Overview","description":"This chapter provides an overview of the building blocks and concepts of Unity Atoms. This knowledge helps you better understand a new way of thinking about data and state in your project.","source":"@site/../docs/introduction/overview.md","sourceDirName":"introduction","slug":"/introduction/overview","permalink":"/unity-atoms/docs/introduction/overview","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Soraphis","lastUpdatedAt":1689977646000,"frontMatter":{"id":"overview","title":"Overview","hide_title":true,"sidebar_label":"Overview"},"sidebar":"docs","previous":{"title":"Philosophy","permalink":"/unity-atoms/docs/introduction/philosophy"},"next":{"title":"Preferences","permalink":"/unity-atoms/docs/introduction/preferences"}}');var i=s(4848),a=s(8453);const r={id:"overview",title:"Overview",hide_title:!0,sidebar_label:"Overview"},o="Overview",l={},c=[{value:"Fundamentals",id:"fundamentals",level:2},{value:"Data",id:"data",level:2},{value:"Variables",id:"variables",level:3},{value:"Pre Change Transformers",id:"pre-change-transformers",level:4},{value:"Constants",id:"constants",level:3},{value:"References",id:"references",level:3},{value:"Variable Instancers",id:"variable-instancers",level:3},{value:"Pairs",id:"pairs",level:3},{value:"Events",id:"events",level:2},{value:"Events",id:"events-1",level:3},{value:"Pair Events",id:"pair-events",level:3},{value:"Event References",id:"event-references",level:3},{value:"Event Instancers",id:"event-instancers",level:3},{value:"Pair Event Instancers",id:"pair-event-instancers",level:3},{value:"Listeners",id:"listeners",level:2},{value:"Event Reference Listeners",id:"event-reference-listeners",level:3},{value:"Pair Event Reference Listeners",id:"pair-event-reference-listeners",level:3},{value:"Responses",id:"responses",level:2},{value:"Actions",id:"actions",level:3},{value:"Pair Actions",id:"pair-actions",level:3},{value:"Functions",id:"functions",level:3},{value:"Collections",id:"collections",level:2},{value:"Value Lists",id:"value-lists",level:3},{value:"Lists",id:"lists",level:3},{value:"Collections",id:"collections-1",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,i.jsx)(n.p,{children:"This chapter provides an overview of the building blocks and concepts of Unity Atoms. This knowledge helps you better understand a new way of thinking about data and state in your project."}),"\n",(0,i.jsx)(n.h2,{id:"fundamentals",children:"Fundamentals"}),"\n",(0,i.jsx)(n.p,{children:"Unity Atoms is an event based system that encourages the game to be as data-driven as possible. The five most fundamental building blocks of Unity Atoms are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data"}),"\n",(0,i.jsx)(n.li,{children:"Events"}),"\n",(0,i.jsx)(n.li,{children:"Listeners"}),"\n",(0,i.jsx)(n.li,{children:"Responses"}),"\n",(0,i.jsx)(n.li,{children:"Collections"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data",children:"Data"}),"\n",(0,i.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,i.jsxs)(n.p,{children:["Variables are data stored as ",(0,i.jsx)(n.a,{href:"https://docs.unity3d.com/Manual/class-ScriptableObject.html",children:"Unity's Scriptable Objects"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Because Variables are stored as Scriptable Objects they are not part of any scene, but could be instead be seen as part of a global shared game state. Variables are also designed to make them easy to inject (via the Unity Inspector) to your MonoBehaviours."}),"\n",(0,i.jsxs)(n.p,{children:["It is possible to attach an Event to a Variable that gets raised when its updated. This makes it possible to write more data-driven code. An Event attached to a Variable could contain only the new value (",(0,i.jsx)(n.code,{children:"Changed"}),") or contain both the new and the old value (",(0,i.jsx)(n.code,{children:"Changed With History"}),")"]}),"\n",(0,i.jsx)(n.h4,{id:"pre-change-transformers",children:"Pre Change Transformers"}),"\n",(0,i.jsxs)(n.p,{children:["You can also add pre change transformers to a Variable. A pre change transformer is an AtomFunction that takes the value type of the Variable, performs some logic, and returns a new value of the same type. It's called on ",(0,i.jsx)(n.code,{children:"OnEnable"})," as well as before setting a new Value of a Variable. An example of a pre change transformer is ",(0,i.jsx)(n.code,{children:"ClampInt"}),", an ",(0,i.jsx)(n.code,{children:"IntIntFunction"})," that clamps the Variable's value between two values."]}),"\n",(0,i.jsx)(n.p,{children:"Your pre change transformers can contain as much or as little logic as necessary for your project and you can chain them in the Inspector."}),"\n",(0,i.jsx)(n.h3,{id:"constants",children:"Constants"}),"\n",(0,i.jsx)(n.p,{children:"Constants behave exactly the same as Variables, but can not be changed via script and therefore do not contain the change Events that Variables do."}),"\n",(0,i.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.p,{children:["References are values that can be toggled between ",(0,i.jsx)(n.code,{children:"Use Value"}),", ",(0,i.jsx)(n.code,{children:"Use Constant"}),", ",(0,i.jsx)(n.code,{children:"Use Variable"})," or ",(0,i.jsx)(n.code,{children:"Use Variable Instancer"})," via the Unity Inspector."]}),"\n",(0,i.jsxs)(n.p,{children:["When a Reference is set to ",(0,i.jsx)(n.code,{children:"Use Value"})," it functions exactly like a regular serialized variable in a MonoBehaviour script. However, when it is set to ",(0,i.jsx)(n.code,{children:"Use Variable"})," or ",(0,i.jsx)(n.code,{children:"Use Constant"})," it uses a Variable or a Constant. When it's set to ",(0,i.jsx)(n.code,{children:"Use Variable Instancer"})," you can drag and drop a Variable Instancer of the correct type."]}),"\n",(0,i.jsx)(n.h3,{id:"variable-instancers",children:"Variable Instancers"}),"\n",(0,i.jsxs)(n.p,{children:["This is a MonoBehaviour that takes a base Variable and makes an in memory copy of it ",(0,i.jsx)(n.code,{children:"OnEnable"}),". This is particular useful when working with prefabs that are going to be instantiated at runtime. You can also give the Variable Instancer a reference to a List or a Collection. If you do that the Variable Instancer will add the in memory Variable on ",(0,i.jsx)(n.code,{children:"Start"})," to the List or Collection and then later remove it on ",(0,i.jsx)(n.code,{children:"OnDestroy"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"pairs",children:"Pairs"}),"\n",(0,i.jsxs)(n.p,{children:["Pairs are simple structs containing two variables of the same type, used for example in Variables' ",(0,i.jsx)(n.code,{children:"Changed With History"})," Event."]}),"\n",(0,i.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.h3,{id:"events-1",children:"Events"}),"\n",(0,i.jsx)(n.p,{children:"An Event is a thing that happens in the game that Listeners can listen for. Events in Unity Atoms are also Scriptable Objects that live outside of a specific scene. It is possible to raise an Event from the Unity Inspector for debugging purposes."}),"\n",(0,i.jsx)(n.h3,{id:"pair-events",children:"Pair Events"}),"\n",(0,i.jsx)(n.p,{children:"Like Event, but for pairs."}),"\n",(0,i.jsx)(n.h3,{id:"event-references",children:"Event References"}),"\n",(0,i.jsxs)(n.p,{children:["Event References are Events that can be toggled between ",(0,i.jsx)(n.code,{children:"Use Event"}),", ",(0,i.jsx)(n.code,{children:"Use Event Instancer"}),", ",(0,i.jsx)(n.code,{children:"Use Variable"})," or ",(0,i.jsx)(n.code,{children:"Use Variable Instancer"})," via the Unity Inspector. When an Event Reference is set to ",(0,i.jsx)(n.code,{children:"Use Event"})," it functions exactly like a regular serialized Event in a MonoBehaviour script. When it is set to ",(0,i.jsx)(n.code,{children:"Use Event Instancer"})," you can drag and drop an Event Instancer whose Event the Event Reference will use. When it is set to ",(0,i.jsx)(n.code,{children:"Use Variable"})," it is going to use the Event associated with the Variable's Changed Event. When it's set to ",(0,i.jsx)(n.code,{children:"Use Variable Instancer"})," you can drag and drop a Variable Instancer of the correct type and it will use its associated Changed Event."]}),"\n",(0,i.jsx)(n.h3,{id:"event-instancers",children:"Event Instancers"}),"\n",(0,i.jsxs)(n.p,{children:["This is a MonoBehaviour that takes a base Event and makes an in memory copy of it on ",(0,i.jsx)(n.code,{children:"OnEnable"}),". This is particularly useful when working with prefabs that are going to be instantiated at runtime, for example when working with Mono Hooks on your prefabs."]}),"\n",(0,i.jsx)(n.h3,{id:"pair-event-instancers",children:"Pair Event Instancers"}),"\n",(0,i.jsx)(n.p,{children:"Like Event Instancer, but for pairs."}),"\n",(0,i.jsx)(n.h2,{id:"listeners",children:"Listeners"}),"\n",(0,i.jsx)(n.h3,{id:"event-reference-listeners",children:"Event Reference Listeners"}),"\n",(0,i.jsx)(n.p,{children:"A Listener listens to an Event reference and raises zero to many responses to that Event Reference. Listeners are MonoBehaviours that live in a scene. See below for more information on the type of responses that is supported."}),"\n",(0,i.jsx)(n.h3,{id:"pair-event-reference-listeners",children:"Pair Event Reference Listeners"}),"\n",(0,i.jsx)(n.p,{children:"Like Event Reference Listeners, but for pairs."}),"\n",(0,i.jsx)(n.h2,{id:"responses",children:"Responses"}),"\n",(0,i.jsxs)(n.p,{children:["Responses are raised by a Listener in response to an Event. Responses can live both in the scene as ",(0,i.jsx)(n.a,{href:"https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html",children:"UnityEvents"})," or outside the scene as a Scriptable Object in the shape of an Action."]}),"\n",(0,i.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,i.jsx)(n.p,{children:"An Action in Unity Atoms is a C# function as a Scriptable Object. An Action can be used as a response in a Listener. Since Scriptable Objects can be created as assets in the project, Actions are well suited for responses that may have different default values."}),"\n",(0,i.jsx)(n.h3,{id:"pair-actions",children:"Pair Actions"}),"\n",(0,i.jsx)(n.p,{children:"Like Actions, but for pairs."}),"\n",(0,i.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.p,{children:"A Function in Unity Atoms is basically the same as an Action, but while an Actions does not return something a Function does."}),"\n",(0,i.jsx)(n.h2,{id:"collections",children:"Collections"}),"\n",(0,i.jsx)(n.p,{children:"Collections store multiple values. For all collections in Unity Atoms there is the possibility to add Events for the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"An item is added."}),"\n",(0,i.jsx)(n.li,{children:"An item is removed."}),"\n",(0,i.jsx)(n.li,{children:"The collection is cleared."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"value-lists",children:"Value Lists"}),"\n",(0,i.jsx)(n.p,{children:"A Value List is an array of values that is stored as a Scriptable Object."}),"\n",(0,i.jsx)(n.h3,{id:"lists",children:"Lists"}),"\n",(0,i.jsx)(n.p,{children:"A List is an array of Variables that is stored as a Scriptable Object. The Variables stored in a List can be of different types."}),"\n",(0,i.jsx)(n.h3,{id:"collections-1",children:"Collections"}),"\n",(0,i.jsx)(n.p,{children:"A collection is a set of Variables associated with a StringReference key and is stored as a Scriptable Object. The Variables stored in a Collection can be of different types."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var t=s(6540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);