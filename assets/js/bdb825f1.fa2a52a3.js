"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[423],{6277:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"subpackages/fsm","title":"FSM","description":"Finite state machine implemented using Unity Atoms.","source":"@site/../docs/subpackages/fsm.md","sourceDirName":"subpackages","slug":"/subpackages/fsm","permalink":"/unity-atoms/docs/subpackages/fsm","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Adam Ramberg","lastUpdatedAt":1689978852000,"frontMatter":{"id":"fsm","title":"FSM","hide_title":true,"sidebar_label":"FSM"},"sidebar":"docs","previous":{"title":"Base Atoms","permalink":"/unity-atoms/docs/subpackages/base-atoms"},"next":{"title":"Input System","permalink":"/unity-atoms/docs/subpackages/input-system"}}');var s=t(4848),a=t(8453);const o={id:"fsm",title:"FSM",hide_title:!0,sidebar_label:"FSM"},l="Unity Atoms / FSM",d={},c=[{value:"What is it?",id:"what-is-it",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Example",id:"example",level:2},{value:"States",id:"states",level:2},{value:"Transitions",id:"transitions",level:2},{value:"Hooks",id:"hooks",level:2},{value:"Funcs",id:"funcs",level:2},{value:"Simple example",id:"simple-example",level:2}];function r(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"unity-atoms--fsm",children:"Unity Atoms / FSM"})}),"\n",(0,s.jsx)(n.p,{children:"Finite state machine implemented using Unity Atoms."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-it",children:"What is it?"}),"\n",(0,s.jsxs)(n.p,{children:["A finite state machine implementation for Unity Atoms. The package was inspired by ",(0,s.jsx)(n.a,{href:"https://github.com/dubit/unity-fsm",children:"this"})," open source Unity FSM repo. The FSM in Unity Atoms is actually derrived from ",(0,s.jsx)(n.code,{children:"StringVariable"}),", so everything you can do with a ",(0,s.jsx)(n.code,{children:"StringVariable"})," you can also do with a FSM."]}),"\n",(0,s.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsx)(n.p,{children:"A finite state machine is composed of 2 things:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"States - a list of possible states. A state is either a string of a sub finite state machine (oh yes, FSM's can be nested)."}),"\n",(0,s.jsx)(n.li,{children:"Transitions - a list of possible transitions. State can only be altered to another state based on the transitions defined here."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In order to change state you need to dispatch a command and that command must be defined in your transitions for the current state."}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["Here is a simple example taken from ",(0,s.jsx)(n.a,{href:"https://github.com/dubit/unity-fsm",children:"here"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'          "CLOSE"               "LOCK"\n    +--------\x3e---------+  +--------\x3e---------+\n    |                  |  |                  |\n +----+              +------+              +------+\n |OPEN|              |CLOSED|              |LOCKED|\n +----+              +------+              +------+\n    |                  |  |                  |\n    +--------<---------+  +--------<---------+\n           "OPEN"                "UNLOCK"\n'})}),"\n",(0,s.jsx)(n.p,{children:"This FSM has 3 states:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"OPEN"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"CLOSED"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LOCKED"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It also has 4 transitions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["From ",(0,s.jsx)(n.code,{children:"OPEN"}),", to ",(0,s.jsx)(n.code,{children:"CLOSED"})," when dispatching ",(0,s.jsx)(n.code,{children:"CLOSE"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["From ",(0,s.jsx)(n.code,{children:"CLOSED"}),", to ",(0,s.jsx)(n.code,{children:"LOCKED"})," when dispatching ",(0,s.jsx)(n.code,{children:"LOCK"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["From ",(0,s.jsx)(n.code,{children:"LOCKED"}),", to ",(0,s.jsx)(n.code,{children:"CLOSED"})," when dispatching ",(0,s.jsx)(n.code,{children:"UNLOCK"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["From ",(0,s.jsx)(n.code,{children:"CLOSED"}),", to ",(0,s.jsx)(n.code,{children:"OPEN"})," when dispatching ",(0,s.jsx)(n.code,{children:"OPEN"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"states",children:"States"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Id"})," - the state name / identifier (string)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Cooldown"})," - if set to above 0 the state machine will re set the state every ",(0,s.jsx)(n.code,{children:"n"})," th seconds where ",(0,s.jsx)(n.code,{children:"n"})," is the cooldown specified in seconds. If for example cooldown is set to 1 and the state id is set to ",(0,s.jsx)(n.code,{children:"SECOND"}),", then the state machine will be set to ",(0,s.jsx)(n.code,{children:"SECOND"})," every second. This means that you will receive that value in the FSM's Changed Event."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Sub Machine"})," - FSMs can be nested. If specified this sub machine will take over resolving the state value."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"transitions",children:"Transitions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"From State"})," - The state that we transition from."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"To State"})," - The state that we transition to."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Command"})," - The command that needs to be dispatched in order to begin this transition."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Test Condition"})," - If specified this condition must be true in order to start the transition."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Raise Event To Complete Transition"})," - If set to true the transition will not complete automatically, Instead you will need to manually Raise the Complete Current Transition Event."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hooks",children:"Hooks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnUpdate"})," - Calls a handler with the state value each Update."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnFixedUpdate"})," - Calls a handler with the state value each FixedUpdate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DispatchWhen"})," - Defines a command that is going to automatically be dispatched when the condition provided is met."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnStateCooldown"})," - Calls the handler of every state cooldown."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"funcs",children:"Funcs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Reset"})," - Reset the FSM."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Dispatch"})," - Dispatch / raise a command."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"simple-example",children:"Simple example"}),"\n",(0,s.jsxs)(n.p,{children:["A simple example showing how you can move a rigidibody towards a target depending on if the current state of the FMS is set to ",(0,s.jsx)(n.code,{children:"CHASING"})," or not."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'public class EnemyMovement : MonoBehaviour\n{\n    [SerializeField]\n    private StringReference _tagToTarget;\n\n    [SerializeField]\n    private FloatReference _shootingRange = new FloatReference(5f);\n\n    [SerializeField]\n    private FloatReference _moveSpeedMultiplier = new FloatReference(2f);\n\n    [SerializeField]\n    private FiniteStateMachineReference _enemyState;\n\n\n    void Awake()\n    {\n        Transform target = null;\n        AtomTags.OnInitialization(() => target = AtomTags.FindByTag(_tagToTarget.Value).transform);\n        var body = GetComponent<Rigidbody2D>();\n\n        _enemyState.Machine.OnUpdate((deltaTime, value) =>\n        {\n            if (target)\n            {\n                body.Move((target.position - transform.position), value == "CHASING" ? 2f : 0f, deltaTime);\n            }\n        }, gameObject);\n        _enemyState.Machine.DispatchWhen(command: "ATTACK", (value) => target != null && value == "CHASING" && (_shootingRange.Value >= Vector3.Distance(target.position, transform.position)), gameObject);\n        _enemyState.Machine.DispatchWhen(command: "CHASE", (value) => target != null && value == "ATTACKING" && (_shootingRange.Value < Vector3.Distance(target.position, transform.position)), gameObject);\n    }\n    }\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);